package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
	"github.com/thatjpcsguy/protohost/internal/git"
)

// NewInitCmd creates the init command
func NewInitCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "init",
		Short: "Initialize protohost in current project",
		Long:  `Creates .protohost.config and sets up the project for protohost deployments.`,
		RunE:  runInit,
	}
}

func runInit(cmd *cobra.Command, args []string) error {
	// Check if .protohost.config already exists
	if _, err := os.Stat(".protohost.config"); err == nil {
		fmt.Println("⚠️  .protohost.config already exists")
		fmt.Print("Overwrite? (y/N): ")
		var response string
		fmt.Scanln(&response)
		if !strings.HasPrefix(strings.ToLower(response), "y") {
			fmt.Println("Aborted")
			return nil
		}
	}

	// Check if we're in a git repository
	if !git.IsGitRepo() {
		fmt.Println("⚠️  Warning: Not in a git repository")
	}

	// Try to detect git remote URL
	repoURL := ""
	if git.IsGitRepo() {
		if url, err := detectGitRemote(); err == nil {
			repoURL = url
		}
	}

	// Infer project prefix from directory name
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	projectPrefix := filepath.Base(cwd)
	projectPrefix = strings.ToLower(projectPrefix)
	projectPrefix = strings.ReplaceAll(projectPrefix, "_", "-")
	projectPrefix = strings.ReplaceAll(projectPrefix, " ", "-")

	// Create .protohost.config from template
	config := generateConfig(projectPrefix, repoURL)
	if err := os.WriteFile(".protohost.config", []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to create .protohost.config: %w", err)
	}

	fmt.Println("✓ Created .protohost.config")

	// Create .protohost/hooks directory
	if err := os.MkdirAll(".protohost/hooks", 0755); err != nil {
		return fmt.Errorf("failed to create .protohost/hooks directory: %w", err)
	}

	// Create hooks README
	hooksReadme := `# Protohost Deploy Hooks

Add custom scripts here to customize deployment behavior:

- pre-deploy.sh   - Runs before deployment starts (locally)
- post-deploy.sh  - Runs after successful deployment (locally)
- post-start.sh   - Runs after containers start (on target)
- first-install.sh - Runs only on first deployment of a branch (on target)

Make sure to chmod +x your hook scripts!

Example post-start.sh:
` + "```bash" + `
#!/bin/bash
# Run database migrations
docker compose -p $PROJECT_NAME exec web python manage.py migrate
` + "```" + `
`

	if err := os.WriteFile(".protohost/hooks/README.md", []byte(hooksReadme), 0644); err != nil {
		return fmt.Errorf("failed to create hooks README: %w", err)
	}

	fmt.Println("✓ Created .protohost/hooks/ directory")

	// Add .protohost.config.local to .gitignore if not already there
	if err := addToGitignore(".protohost.config.local"); err != nil {
		fmt.Printf("Warning: failed to update .gitignore: %v\n", err)
	} else {
		fmt.Println("✓ Updated .gitignore")
	}

	// Success message
	fmt.Println()
	fmt.Println("✅ Protohost initialized successfully!")
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Println("  1. Review and update .protohost.config with your settings")
	fmt.Println("  2. Ensure docker-compose.yml uses ${WEB_PORT} for port mapping")
	fmt.Println("  3. Run 'protohost deploy' to test locally")
	fmt.Println("  4. Run 'protohost deploy --remote' to deploy to server")
	fmt.Println()

	return nil
}

func generateConfig(projectPrefix, repoURL string) string {
	if repoURL == "" {
		repoURL = "git@github.com:user/repo.git"
	}

	return fmt.Sprintf(`# Protohost Deploy Configuration
# Generated by protohost init

# Project configuration
PROJECT_PREFIX="%s"
REPO_URL="%s"
TTL_DAYS=7

# Remote server configuration
REMOTE_HOST="protohost.xyz"
REMOTE_USER="${USER}"
REMOTE_BASE_DIR="~/protohost"

# Network configuration
# NGINX_PROXY_HOST: IP address where Docker containers are running
# NGINX_SERVER: IP address where nginx is running (can be same or different)
NGINX_PROXY_HOST="10.10.20.4"
NGINX_SERVER="10.10.20.10"

# Optional: Port configuration
BASE_WEB_PORT=3000

# Optional: SSL configuration
# SSL_CERT_PATH="/etc/letsencrypt/live/protohost.xyz/fullchain.pem"
# SSL_KEY_PATH="/etc/letsencrypt/live/protohost.xyz/privkey.pem"

# Optional: Hook scripts (executed during deployment)
# These run if corresponding hook files don't exist in .protohost/hooks/
# PRE_DEPLOY_SCRIPT=""              # Runs locally before deployment starts
# POST_DEPLOY_SCRIPT=""             # Runs locally after deployment completes
# POST_START_SCRIPT=""              # Runs on target after containers start
# FIRST_INSTALL_SCRIPT=""           # Runs on target only on first deployment
`, projectPrefix, repoURL)
}

func detectGitRemote() (string, error) {
	cmd := exec.Command("git", "config", "--get", "remote.origin.url")
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}

	return strings.TrimSpace(string(output)), nil
}

func addToGitignore(entry string) error {
	// Check if .gitignore exists
	content := []byte{}
	if data, err := os.ReadFile(".gitignore"); err == nil {
		content = data

		// Check if entry already exists
		if strings.Contains(string(content), entry) {
			return nil
		}
	}

	// Append entry
	newContent := string(content)
	if len(content) > 0 && !strings.HasSuffix(newContent, "\n") {
		newContent += "\n"
	}
	newContent += "\n# Protohost deploy - only ignore local overrides\n"
	newContent += entry + "\n"

	return os.WriteFile(".gitignore", []byte(newContent), 0644)
}
